<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üßç Owner Portal - Privacy-Preserving LBS</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <style>
    body {
      font-family: 'Inter', sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f0f4f8;
    }
    h2 { color: #1a202c; font-size: 1.8rem; margin-bottom: 20px; }
    section {
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.05);
    }
    h3 { color: #2d3748; font-size: 1.25rem; margin-top: 0; margin-bottom: 15px; }
    input, button {
      padding: 10px 12px;
      margin: 5px 0;
      border-radius: 8px;
      border: 1px solid #cbd5e0;
      box-sizing: border-box;
      width: 100%;
    }
    button {
      background-color: #4299e1;
      color: white;
      border: none;
      cursor: pointer;
      font-weight: 600;
      transition: background-color 0.2s;
      margin-top: 10px;
    }
    button:hover {
      background-color: #3182ce;
    }
    #map {
      width: 100%;
      height: 60vh;
      min-height: 400px;
      margin-top: 20px;
      border: 1px solid #ccc;
      border-radius: 12px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }
    @media (min-width: 640px) {
      .input-group {
        display: flex;
        gap: 10px;
        align-items: stretch;
      }
      .input-group > * {
        flex-grow: 1;
        width: auto;
        margin: 0;
      }
      .input-group button {
        flex-shrink: 0;
        width: auto;
      }
    }
  </style>
</head>
<body>
  <h2>üßç Owner Portal</h2>

  <!-- üîç Section 1: Location Search -->
  <section>
    <h3>üîç Search Locations</h3>
    <p>Search for places (e.g., hospital, cafe, school). Your real and dummy locations will appear on the map.</p>
    <div class="input-group">
      <input type="text" id="query" placeholder="Enter place (e.g. hospital)" />
      <input type="password" id="passphrase" placeholder="Enter passphrase" />
    </div>
    <button onclick="searchOnly()">Search</button>
  </section>

  <!-- üîê Section 2: Grant Access -->
  <section>
    <h3>üîê Grant Access to Viewer</h3>
    <p>Grant location access permission to a viewer without re-running the location search.</p>
    <div class="input-group">
      <input type="text" id="owner" placeholder="Owner ID (e.g. user123)" />
      <input type="text" id="viewer" placeholder="Viewer ID (e.g. agent456)" />
    </div>
    <div class="input-group">
      <input type="number" id="duration" placeholder="Duration (minutes)" min="1" value="5" />
      <button onclick="grantAccessOnly()" style="background-color: #48bb78;">Grant Access</button>
    </div>
    <button onclick="window.location.href='/viewer'" style="background-color: #ed8936;">Go to Viewer Page ‚ûú</button>
  </section>

  <div id="map"></div>

  <script>
let map;

// ‚úÖ DYNAMIC API BASE URL - Automatically detects environment
const API_BASE_URL = (() => {
  const hostname = window.location.hostname;
  
  // If running on localhost or 127.0.0.1, use localhost with port
  if (hostname === 'localhost' || hostname === '127.0.0.1') {
    return 'http://localhost:5000';
  }
  
  // If running on Render deployment
  if (hostname === 'plqp-project.onrender.com') {
    return 'https://plqp-project.onrender.com';
  }
  
  // Fallback to current origin for any other deployment
  return window.location.origin;
})();

console.log('üåê API Base URL:', API_BASE_URL);

// ======================= MAP SETUP =======================
function initMap(lat, lon) {
  console.log("%cüó∫ Initializing map...", "color: dodgerblue;");
  try {
    if (map) {
      console.log("%c‚ôª Removing previous map instance", "color: orange;");
      map.remove();
    }
    map = L.map("map").setView([lat, lon], 14);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom: 19 }).addTo(map);
    console.log("%c‚úÖ Map initialized successfully", "color: green;");
  } catch (err) {
    console.error("‚ùå Error initializing map:", err);
  }
}

function addMarker(lat, lon, color = "blue", text = "Marker") {
  try {
    console.log(`üìç Adding marker (${color}) at [${lat}, ${lon}] ‚Äî ${text}`);

    // ‚úÖ Correct CDN for colored Leaflet markers
    const icon = L.icon({
      iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-${color}.png`,
      shadowUrl: "https://unpkg.com/leaflet@1.9.3/dist/images/marker-shadow.png",
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    });

    if (isNaN(lat) || isNaN(lon)) {
      throw new Error(`Invalid coordinates: lat=${lat}, lon=${lon}`);
    }

    // ‚úÖ Add marker to the map
    const marker = L.marker([lat, lon], { icon }).addTo(map);
    marker.bindPopup(text);
  } catch (err) {
    console.error(`‚ùå Failed to add marker at [${lat}, ${lon}] ‚Üí`, err.message);
  }
}

// ======================= CRYPTO HELPERS =======================
function hexToBytes(hex) {
  if (!hex || typeof hex !== "string" || hex.length % 2 !== 0) {
    console.error("‚ö† Invalid hex input:", hex);
    return new Uint8Array();
  }
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2)
    bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
  return bytes;
}

async function deriveKey(passphrase, saltHex) {
  console.log("%cüîë Deriving decryption key...", "color: cyan;");
  try {
    const enc = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(passphrase), "PBKDF2", false, ["deriveKey"]);
    const salt = hexToBytes(saltHex);
    return await crypto.subtle.deriveKey(
      { name: "PBKDF2", salt, iterations: 200000, hash: "SHA-256" },
      keyMaterial,
      { name: "AES-GCM", length: 256 },
      false,
      ["decrypt"]
    );
  } catch (err) {
    console.error("‚ùå Error deriving key:", err);
    return null;
  }
}

async function decryptEnvelope(envelope, passphrase) {
  console.log("%cüì¶ Decrypting envelope...", "color: violet;", envelope);
  try {
    if (!envelope.salt_hex) {
      console.warn("‚ö† salt_hex missing from envelope, using default fallback salt.");
      envelope.salt_hex = Array.from(
        new TextEncoder().encode("plqp-salt-2025")
      ).map(b => b.toString(16).padStart(2, "0")).join("");
    }

    if (!envelope.nonce_hex || !envelope.tag_hex || !envelope.ciphertext_hex) {
      console.error("‚ùå Incomplete encryption envelope:", envelope);
      return null; 
    }

    const nonce = hexToBytes(envelope.nonce_hex);
    const tag = hexToBytes(envelope.tag_hex);
    const ciphertext = hexToBytes(envelope.ciphertext_hex);
    const combined = new Uint8Array(ciphertext.length + tag.length);
    combined.set(ciphertext);
    combined.set(tag, ciphertext.length);

    const key = await deriveKey(passphrase, envelope.salt_hex);
    if (!key) return null;

    const plaintext = await crypto.subtle.decrypt({ name: "AES-GCM", iv: nonce }, key, combined);
    const decrypted = JSON.parse(new TextDecoder().decode(plaintext));
    console.log("%c‚úÖ Decryption successful:", "color: green;", decrypted);
    return decrypted;
  } catch (err) {
    console.error("‚ùå Error decrypting data:", err);
    alert("Decryption failed. Check passphrase or server data.");
    return null;
  }
}

// ======================= üîê GRANT ACCESS =======================
async function grantAccessOnly() {
  console.log("%cüîê Starting grantAccessOnly() process...", "color: lightgreen;");
  const owner = document.getElementById("owner").value.trim();
  const viewer = document.getElementById("viewer").value.trim();
  const duration = parseInt(document.getElementById("duration").value.trim() || "5");

  if (!owner || !viewer) {
    alert("‚ö† Please fill in the Owner ID and Viewer ID to grant access.");
    return;
  }

  console.log(`Attempting to grant Viewer (${viewer}) access to Owner (${owner}) for ${duration} minutes...`);
  try {
    const grant = await fetch(`${API_BASE_URL}/partner/grant_access`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ owner, viewer, duration_minutes: duration }),
    });
    const grantRes = await grant.json();
    console.log("%c‚úÖ Access grant response:", "color: lightgreen;", grantRes);

    if (grantRes.error) {
      alert("‚ùå Error granting access: " + grantRes.error);
    } else {
      alert(`‚úÖ Access successfully granted to Viewer (${viewer}) for ${duration} minutes.`);
    }
  } catch (err) {
    console.error("‚ùå Network error during grantAccessOnly:", err);
    alert("‚ùå Network error while granting access. Check server connection.");
  }
}

// ======================= üîç SEARCH =======================
async function searchOnly() {
  console.log("%cüöÄ Starting searchOnly() process...", "color: orange;");
  const query = document.getElementById("query").value.trim();
  const passphrase = document.getElementById("passphrase").value.trim();
  const owner = "default_owner_for_search"; 
  
  if (!query || !passphrase) {
    alert("‚ö† Please fill in Search Query and Passphrase.");
    return;
  }

  if (!navigator.geolocation) {
    alert("‚ùå Geolocation not supported.");
    return;
  }

  new Promise((resolve, reject) => navigator.geolocation.getCurrentPosition(resolve, reject))
  .then(async (pos) => {
    const lat = pos.coords.latitude;
    const lon = pos.coords.longitude;
    console.log("%cüìç Current position:", "color: yellow;", { lat, lon });
    initMap(lat, lon);

    try {
      const res = await fetch(`${API_BASE_URL}/user/search`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ query, lat, lon, owner }),
      });
      const data = await res.json();
      console.log("%cüì® Received search response:", "color: limegreen;", data);

      if (data.error) {
        alert("‚ùå Error fetching places: " + data.error);
        return;
      }

      const decrypted = await decryptEnvelope(data.enc_data, passphrase);
      if (!decrypted) {
        console.warn("‚ö† Decryption returned null ‚Äî skipping markers.");
        return;
      }

      console.log("%cüß≠ Rendering map markers...", "color: yellow;");
      addMarker(lat, lon, "red", "üìç Your Location");

      console.log("%cüì¶ Dummies data structure:", "color: lightblue;", decrypted.dummies);
      
      if (decrypted.dummies && decrypted.dummies.length) {
        console.log(`üîµ Rendering ${decrypted.dummies.length} dummy markers...`);
        decrypted.dummies.forEach((d, i) => {
          console.log("Dummy data:", d);
          if (d.lat && d.lon) {
            console.log(`üìç Adding dummy marker ${i + 1} at [${d.lat}, ${d.lon}]`);
            addMarker(d.lat, d.lon, "blue", `üåÄ Dummy ${i + 1}`);
          } else {
            console.warn(`‚ö† Dummy ${i + 1} missing coordinates:`, d);
          }
        });
      } else {
        console.warn("‚ö† No dummy markers found in decrypted data.");
      }

      (decrypted.merged_places || []).forEach((p, i) => {
        const markerLat = p.lat || (p.geometry?.location?.lat ?? null);
        const markerLon = p.lon || (p.geometry?.location?.lon ?? null);
        if (markerLat && markerLon) {
          addMarker(markerLat, markerLon, "green", `${p.name || "Unnamed Place"}<br>${p.vicinity || p.address || ""}`);
        }
      });

      console.log("%cüéØ Marker rendering completed!", "color: green;");
    } catch (err) {
      console.error("‚ùå Network/search error:", err);
      alert("‚ùå Network error during search.");
    }
  })
  .catch((err) => alert("‚ùå GPS error: " + err.message));
}

document.addEventListener("DOMContentLoaded", () => initMap(37.422, -122.084));
</script>
</body>
</html>